/**
 * BlogEntriesFetcher
 * 
 * Dynamically fetches blog posts from the entries directory, parses their frontmatter,
 * and renders an expandable list of blog posts.
 * 
 * @module BlogEntriesFetcher
 */
class BlogEntriesFetcher {
  /**
   * Creates an instance of BlogEntriesFetcher
   */
  constructor() {
    this.posts = [];
    this.postsListElement = document.getElementById("posts-list");
    this.postContainerElement = document.getElementById("post-container");
  }

  /**
   * Initializes the blog fetcher by fetching and rendering blog posts
   * 
   * @async
   * @returns {Promise<void>}
   */
  async init() {
    await this.fetchAndParseBlogPosts();
    this.renderBlogList();
  }

  /**
   * Fetches and parses all blog posts from the entries directory
   * 
   * @async
   * @returns {Promise<void>}
   */
  async fetchAndParseBlogPosts() {
    // List of known blog posts - in a real implementation with a backend,
    // this would be dynamically generated by scanning the directory
    const blogPostFiles = ["entries/post-1.md", "entries/blog-2.md"];

    try {
      // Fetch all blog posts concurrently
      const fetchPromises = blogPostFiles.map((file) =>
        this.fetchBlogPost(file),
      );
      const posts = await Promise.all(fetchPromises);

      // Filter out any failed requests
      this.posts = posts.filter((post) => post !== null);
    } catch (error) {
      console.error("Error fetching blog posts:", error);
    }
  }

  /**
   * Fetches and parses a single blog post
   * 
   * @async
   * @param {string} filePath - The path to the markdown file
   * @returns {Promise<Object|null>} The parsed blog post object or null if failed
   */
  async fetchBlogPost(filePath) {
    try {
      const response = await fetch(filePath);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${filePath}: ${response.status}`);
      }

      const markdown = await response.text();
      const { frontmatter, content } = this.parseFrontmatter(markdown);

      // Generate an ID from the filename
      const id = filePath
        .replace("entries/", "")
        .replace(".md", "")
        .replace("/", "-")
        .toLowerCase();

      // Extract summary from the first paragraph or line of content
      const summary = this.extractSummary(content);

      return {
        id,
        file: filePath,
        title: frontmatter.title || "Untitled",
        date: frontmatter.date || "",
        author: frontmatter.author || "Anonymous",
        summary,
        tags: Array.isArray(frontmatter.tags) ? frontmatter.tags : [],
        content, // We might not need this for the listing
      };
    } catch (error) {
      console.error(`Error fetching ${filePath}:`, error);
      return null;
    }
  }

  /**
   * Parses frontmatter from markdown content
   * 
   * @param {string} markdown - The raw markdown content with frontmatter
   * @returns {Object} Object containing frontmatter metadata and content
   */
  parseFrontmatter(markdown) {
    const frontmatterRegex = /^---\s*\n([\s\S]*?)\n---\s*\n([\s\S]*)$/;
    const match = markdown.match(frontmatterRegex);

    if (match) {
      const frontmatterRaw = match[1];
      const content = match[2];

      // Parse frontmatter as key-value pairs
      const frontmatter = {};
      const lines = frontmatterRaw.split("\n");
      lines.forEach((line) => {
        const colonIndex = line.indexOf(":");
        if (colonIndex > 0) {
          const key = line.substring(0, colonIndex).trim();
          let value = line.substring(colonIndex + 1).trim();

          // Remove quotes if present
          if (value.startsWith('"') && value.endsWith('"')) {
            value = value.slice(1, -1);
          } else if (value.startsWith("[") && value.endsWith("]")) {
            // Parse arrays
            value = value
              .slice(1, -1)
              .split(",")
              .map((item) => {
                const trimmed = item.trim();
                return trimmed.startsWith('"') && trimmed.endsWith('"')
                  ? trimmed.slice(1, -1)
                  : trimmed;
              });
          }

          frontmatter[key] = value;
        }
      });

      return { frontmatter, content };
    }

    return { frontmatter: {}, content: markdown };
  }

  /**
   * Extracts a summary from the content (first paragraph or first few sentences)
   * 
   * @param {string} content - The markdown content
   * @returns {string} A summary of the content
   */
  extractSummary(content) {
    // Remove frontmatter if present
    const contentWithoutFrontmatter = content.replace(
      /^---\s*\n[\s\S]*?\n---\s*\n/,
      "",
    );

    // Get the first paragraph or first few sentences
    const paragraphs = contentWithoutFrontmatter.split("\n\n");
    if (paragraphs.length > 0 && paragraphs[0].trim() !== "") {
      return paragraphs[0].trim();
    }

    // Fallback to first 100 characters
    const text = contentWithoutFrontmatter.replace(/[#*`]/g, "").trim();
    return text.substring(0, 100) + (text.length > 100 ? "..." : "");
  }

  /**
   * Renders the list of blog posts
   */
  renderBlogList() {
    if (!this.postsListElement) return;

    if (this.posts.length === 0) {
      this.postsListElement.innerHTML = "<p>No blog posts available.</p>";
      return;
    }

    // Sort posts by date (newest first)
    const sortedPosts = [...this.posts].sort((a, b) => {
      if (a.date && b.date) {
        return new Date(b.date) - new Date(a.date);
      }
      return 0;
    });

    this.postsListElement.innerHTML = sortedPosts
      .map(
        (post) => `
      <div class="post-item collapsed" data-id="${post.id}">
        <h2>${post.title}</h2>
        <div class="post-meta">
          ${post.date ? `Date: ${post.date}` : ""}
          ${post.author ? ` | Author: ${post.author}` : ""}
        </div>
        <div class="post-summary">${post.summary}</div>
      </div>
    `,
      )
      .join("");

    // Add event listeners to expand/collapse posts
    document.querySelectorAll(".post-item").forEach((item) => {
      item.addEventListener("click", (e) => {
        this.togglePost(item.getAttribute("data-id"));
      });
    });
  }

  /**
   * Toggles the expansion of a blog post
   * 
   * @param {string} postId - The ID of the post to toggle
   */
  togglePost(postId) {
    const postElement = document.querySelector(
      `.post-item[data-id="${postId}"]`,
    );

    // If post is already expanded, collapse it
    if (postElement.classList.contains("expanded")) {
      postElement.classList.remove("expanded");
      postElement.classList.add("collapsed");
      this.postContainerElement.innerHTML = "";
      return;
    }

    // Collapse all other posts
    document.querySelectorAll(".post-item").forEach((item) => {
      item.classList.remove("expanded");
      item.classList.add("collapsed");
    });

    // Expand the selected post
    postElement.classList.remove("collapsed");
    postElement.classList.add("expanded");

    // Load and display the post content
    const post = this.posts.find((p) => p.id === postId);
    if (post) {
      this.postContainerElement.innerHTML = `<blog-post src="${post.file}"></blog-post>`;
    }
  }
}

// Initialize the blog when the page loads
document.addEventListener("DOMContentLoaded", () => {
  const blogFetcher = new BlogEntriesFetcher();
  blogFetcher.init();
});
